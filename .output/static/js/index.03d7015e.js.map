{"version":3,"file":"static/js/index.03d7015e.js","sources":["webpack://voice-bot-fe/./src/utils/constant.ts","webpack://voice-bot-fe/./src/routes/utils.ts","webpack://voice-bot-fe/./src/utils/voice_bot_service.ts","webpack://voice-bot-fe/./src/utils/index.ts","webpack://voice-bot-fe/./src/routes/page.tsx","webpack://voice-bot-fe/./src/App.tsx","webpack://voice-bot-fe/./src/modern.runtime.ts","webpack://voice-bot-fe/"],"sourcesContent":["export const CONST = {\n  PROTOCOL_VERSION: 0b0001,\n  DEFAULT_HEADER_SIZE: 0b0001,\n\n  // Header size\n  PROTOCOL_VERSION_BITS: 4,\n  HEADER_BITS: 4,\n  MESSAGE_TYPE_BITS: 4,\n  MESSAGE_TYPE_SPECIFIC_FLAGS_BITS: 4,\n  MESSAGE_SERIALIZATION_BITS: 4,\n  MESSAGE_COMPRESSION_BITS: 4,\n  RESERVED_BITS: 8,\n  // Payload Length\n  PAYLOAD_LENGTH_BITES: 32,\n  PAYLOAD_LENGTH_BYTES: 4,\n\n  // Message Type:\n  CLIENT_FULL_REQUEST: 0b0001,\n  CLIENT_AUDIO_ONLY_REQUEST: 0b0010,\n  SERVER_FULL_RESPONSE: 0b1001,\n  SERVER_AUDIO_ONLY_RESPONSE: 0b1011,\n  SERVER_ACK: 0b1011,\n  SERVER_ERROR_RESPONSE: 0b1111,\n\n  // Message Type Specific Flags\n  NO_SEQUENCE: 0b0000, // no check sequence\n  POS_SEQUENCE: 0b0001,\n  NEG_WITHOUT_SEQUENCE: 0b0010,\n  NEG_WITH_SEQUENCE: 0b0011,\n\n  // Message Serialization\n  NO_SERIALIZATION: 0b0000,\n  JSON: 0b0001,\n  THRIFT: 0b0011,\n  CUSTOM_TYPE: 0b1111,\n\n  // Message Compression\n  NO_COMPRESSION: 0b0000,\n  GZIP: 0b0001,\n  CUSTOM_COMPRESSION: 0b1111,\n};\n","import { CONST } from '@/utils/constant';\nimport type { IWebSocketResponse, JSONResponse } from '@/utils/type';\n\nexport const encodeAudioOnlyRequest = (requestData: Blob) => {\n  const audio_only_request_header = generateHeader(\n    CONST.CLIENT_AUDIO_ONLY_REQUEST,\n  );\n  audio_only_request_header.setUint32(4, requestData.size, false);\n  return new Blob([audio_only_request_header, requestData]);\n};\n\nconst generateHeader = (message_type = CONST.CLIENT_FULL_REQUEST) => {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setUint8(\n    0,\n    (CONST.PROTOCOL_VERSION << 4) | CONST.DEFAULT_HEADER_SIZE,\n  );\n  dataView.setUint8(1, (message_type << 4) | CONST.NO_SEQUENCE);\n  dataView.setUint8(2, (CONST.JSON << 4) | CONST.NO_COMPRESSION);\n  dataView.setUint8(3, 0x00);\n  return dataView;\n};\n\nexport const generateWSHeader = (msgType = CONST.CLIENT_AUDIO_ONLY_REQUEST) => {\n  const buffer = new ArrayBuffer(8);\n  const dataView = new DataView(buffer);\n  dataView.setUint8(\n    0,\n    (CONST.PROTOCOL_VERSION << 4) | CONST.DEFAULT_HEADER_SIZE,\n  );\n  dataView.setUint8(1, msgType << 4 || CONST.NO_SEQUENCE);\n  dataView.setUint8(2, (CONST.JSON << 4) | CONST.NO_COMPRESSION);\n  dataView.setUint8(3, 0x00);\n\n  return dataView;\n};\n\nexport type BotWebRequest = {\n  event: string;\n  payload?: Record<string, any>;\n  data?: Blob;\n};\nexport const genBotWSData = (req: BotWebRequest) => {\n  const header = generateWSHeader();\n  const data = req.data || new Blob([]);\n  const json = JSON.stringify({\n    event: req.event,\n    payload: req.payload || {},\n  });\n  const byteLength = new TextEncoder().encode(json).length;\n  header.setUint32(4, byteLength, false);\n  header.setUint32(8, data.size || 0, false);\n  return new Blob([header, json, data]);\n};\n\nexport const decodeWebSocketResponse = (\n  resp: ArrayBuffer,\n): IWebSocketResponse => {\n  const view = new DataView(resp);\n  const header_size = view.getUint8(0) & 0x0f; // 0~3 bits\n  const messageType = getHighNibble(view.getUint8(1));\n  // const messageType = view.getUint8(1) & 0x0f; // 4~7 bits\n  const payload = resp.slice(header_size * CONST.HEADER_BITS);\n  const payloadSize = new DataView(payload).getUint32(0);\n  const payloadBody = payload.slice(CONST.PAYLOAD_LENGTH_BYTES);\n  if (messageType === CONST.SERVER_AUDIO_ONLY_RESPONSE) {\n    return {\n      messageType: CONST.SERVER_AUDIO_ONLY_RESPONSE,\n      payload: payload.slice(\n        CONST.PAYLOAD_LENGTH_BYTES,\n        CONST.PAYLOAD_LENGTH_BYTES + payloadSize,\n      ),\n    };\n  }\n  return {\n    messageType: CONST.SERVER_FULL_RESPONSE,\n    payload: JSON.parse(new TextDecoder().decode(payloadBody)),\n  };\n};\n\nexport const handleJSONMessage = (msg: JSONResponse) => {\n  const { event, payload } = msg;\n  console.log('handleMessage', event, payload);\n  if (!event) {\n    return;\n  }\n  switch (event) {\n    case 'BotReady':\n      console.log('BotReady', payload);\n      break;\n    case 'BotUpdateConfig':\n      console.log('BotUpdateConfig', payload);\n      break;\n    case 'SentenceRecognized':\n      console.log('SentenceRecognized', payload);\n      break;\n    case 'TTSSentenceStart':\n      console.log('TTSSentenceStart', payload);\n      break;\n    case 'TTSDone':\n      console.log('TTSDone', payload);\n      break;\n    case 'BotError':\n      console.log('BotError', payload);\n      break;\n    default:\n      console.log('Unknown event', event, payload);\n      break;\n  }\n};\nconst getHighNibble = (byte: number) => {\n  return (byte >> 4) & 0x0f;\n};\n","import { decodeWebSocketResponse, handleJSONMessage } from '@/routes/utils';\nimport { pack } from '.';\nimport type { JSONResponse, WebRequest } from './type';\nimport { CONST } from '@/utils/constant';\n\ninterface IVoiceBotService {\n  ws_url: string;\n}\nexport default class VoiceBotService {\n  private ws_url: string;\n  private ws?: WebSocket;\n  private audioCtx: AudioContext;\n  constructor(props: IVoiceBotService) {\n    this.ws_url = props.ws_url;\n    this.audioCtx = new AudioContext();\n  }\n  public async connect(): Promise<WebSocket> {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket(this.ws_url);\n      ws.onopen = () => {\n        this.ws = ws;\n        resolve(ws);\n      };\n      ws.onerror = e => {\n        reject(e);\n        this.onError(e);\n      };\n      ws.onmessage = e => this.onMessage(e);\n    });\n  }\n\n  // 发送消息\n  public sendMessage(message: WebRequest) {\n    this.ws?.send(pack(message));\n  }\n\n  // 接收消息\n  public onMessage(e: MessageEvent<any>) {\n    try {\n      e.data.arrayBuffer().then((buffer: ArrayBuffer) => {\n        const resp = decodeWebSocketResponse(buffer);\n        console.log('##resp', resp);\n        if (resp.messageType === CONST.SERVER_FULL_RESPONSE) {\n          handleJSONMessage(resp.payload as JSONResponse);\n        }\n        if (resp.messageType === CONST.SERVER_AUDIO_ONLY_RESPONSE) {\n          this.handleAudioOnlyResponse(resp.payload as ArrayBuffer);\n        }\n        // handleMessage?.(json);\n      });\n    } catch (e) {\n      this.onError(e);\n    }\n  }\n  private async handleAudioOnlyResponse(data: ArrayBuffer) {\n    const audioBuffer = await this.audioCtx.decodeAudioData(\n      new Uint8Array(data).buffer,\n    );\n    const buffer = this.audioCtx.createBufferSource();\n    buffer.buffer = audioBuffer;\n    buffer.connect(this.audioCtx.destination);\n    buffer.start(0);\n  }\n  private onError(e: any) {\n    console.error(e);\n    this.dispose();\n  }\n  private dispose() {\n    this.ws?.close();\n  }\n}\n","import { EventType, type WebRequest, type WebResponse } from '@/utils/type';\nimport { generateWSHeader } from '@/routes/utils';\nimport { CONST } from '@/utils/constant';\n\nexport function unpack(resp: ArrayBuffer): WebResponse {\n  const view = new DataView(resp);\n  const hsize = view.getUint8(0) & 0x0f;\n  let body = resp.slice(hsize * 4);\n  const payloadSize = new DataView(body).getUint32(0);\n  body = body.slice(4);\n  const dataSize = new DataView(body).getUint32(0);\n  // json part\n  const raw = body.slice(4, 4 + payloadSize);\n  const result = JSON.parse(new TextDecoder().decode(raw));\n  // audio part\n  if (dataSize > 0) {\n    result.data = body.slice(4 + payloadSize);\n  }\n  return result;\n}\n\n/**\n * web send ws data\n */\nexport function pack(req: WebRequest): Blob {\n  if (req.payload) {\n    const header = generateWSHeader(CONST.CLIENT_FULL_REQUEST);\n    const json = JSON.stringify(req.payload);\n    const encoded = new TextEncoder().encode(json);\n    const byteLength = encoded.length;\n    header.setUint32(4, byteLength, false);\n    return new Blob([header, json]);\n  }\n  const header = generateWSHeader();\n  const data = req.data || new Blob();\n  // req.data = undefined;\n\n  // const json = JSON.stringify(req);\n  // const encoded = new TextEncoder().encode(json);\n  // const byteLength = encoded.length;\n\n  // header.setUint32(4, byteLength, false);\n  header.setUint32(4, data.size, false);\n\n  return new Blob([header, data]);\n}\n","import {\n  encodeAudioOnlyRequest,\n  genBotWSData,\n  decodeWebSocketResponse,\n  handleJSONMessage,\n} from '@/routes/utils';\nimport { Button } from '@arco-design/web-react';\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport RecordRTC, { StereoAudioRecorder } from 'recordrtc';\nimport './index.css';\nimport VoiceBotService from '@/utils/voice_bot_service';\n\nconst Index = () => {\n  const recorderRef = useRef<RecordRTC>();\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [ASRResult, setASRResult] = useState<string>('');\n  const webSocketRef = useRef<WebSocket>();\n  const voiceBotService = useRef<VoiceBotService>();\n  const getUserMedia = useCallback(async () => {\n    return new Promise((resolve, reject) => {\n      if (navigator.mediaDevices.getUserMedia) {\n        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {\n          mediaStream.current = stream;\n          resolve(stream);\n        });\n      } else {\n        reject(null);\n      }\n    });\n  }, []);\n\n  const connectWebsocket = useCallback((): Promise<WebSocket> => {\n    const botService = new VoiceBotService({\n      // ws_url: 'ws://localhost:8888/api/voice/chat',\n      ws_url: 'ws://10.254.198.22:8888/api/voice/chat',\n    });\n    voiceBotService.current = botService;\n    return botService.connect();\n  }, []);\n\n  const startRecord = useCallback(async () => {\n    try {\n      const socket = await connectWebsocket();\n      webSocketRef.current = socket;\n      await getUserMedia();\n      if (!mediaStream.current) {\n        return;\n      }\n      recorderRef.current = new RecordRTC(mediaStream.current, {\n        type: 'audio',\n        recorderType: StereoAudioRecorder,\n        mimeType: 'audio/wav',\n        numberOfAudioChannels: 1,\n        desiredSampRate: 16000,\n        disableLogs: true,\n        timeSlice: 100,\n        async ondataavailable(recordResult) {\n          const socket = webSocketRef.current;\n          const botService = voiceBotService.current;\n          if (!socket || !botService) {\n            return;\n          }\n          const pcm = recordResult.slice(44);\n          const data = encodeAudioOnlyRequest(pcm);\n          if (socket.readyState === socket.OPEN) {\n            botService.sendMessage({\n              event: 'UserAudio',\n              data,\n            });\n          }\n        },\n      });\n      recorderRef.current.startRecording();\n    } catch (e) {\n      console.error(e);\n    }\n  }, [getUserMedia, connectWebsocket]);\n\n  return (\n    <div className=\"root\">\n      <Button\n        onClick={() => {\n          startRecord();\n        }}\n      >\n        开始对话\n      </Button>\n      <p>语音识别结果: {ASRResult}</p>\n    </div>\n  );\n};\n\nexport default Index;\n","import { BrowserRouter, Route, Routes } from '@modern-js/runtime/router';\nimport Home from './routes/page'\nexport default () => {\n    return (\n        <BrowserRouter>\n            <Routes>\n                {/*<Route index element={<div>index</div>} />*/}\n                <Route path=\"/\" element={<Home/>} />\n            </Routes>\n        </BrowserRouter>\n    );\n};","import { defineRuntimeConfig } from '@modern-js/runtime';\n\nexport default defineRuntimeConfig({});\n","import \"core-js\";"],"names":["CONST","encodeAudioOnlyRequest","requestData","audio_only_request_header","generateHeader","Blob","message_type","dataView","DataView","ArrayBuffer","VoiceBotService","Promise","resolve","reject","ws","WebSocket","e","message","_this_ws","pack","req","header","generateWSHeader","json","JSON","byteLength","encoded","TextEncoder","header1","data","buffer","resp","decodeWebSocketResponse","console","handleJSONMessage","audioBuffer","Uint8Array","props","AudioContext","recorderRef","useRef","mediaStream","ASRResult","setASRResult","useState","webSocketRef","voiceBotService","getUserMedia","useCallback","navigator","stream","connectWebsocket","botService","startRecord","socket","RecordRTC","StereoAudioRecorder","recordResult","pcm","Button","BrowserRouter","Routes","defineRuntimeConfig","window"],"mappings":"wNAAaA,EAAQ,CACnB,iBAAkB,EAClB,oBAAqB,EAIrB,YAAa,EAQb,qBAAsB,EAGtB,oBAAqB,EACrB,0BAA2B,EAC3B,qBAAsB,EACtB,2BAA4B,GAK5B,YAAa,EAOb,KAAM,EAKN,eAAgB,CAGlB,ECrCaC,EAAyB,AAACC,IACrC,IAAMC,EAA4BC,EAChCJ,EAAM,yBAAyB,EAGjC,OADAG,EAA0B,SAAS,CAAC,EAAGD,EAAY,IAAI,CAAE,IAClD,IAAIG,KAAK,CAACF,EAA2BD,EAAY,CAC1D,EAEME,EAAiB,W,IAACE,EAAe,UAAfA,MAAAA,CAAAA,GAAAA,AAAAA,KAAAA,IAAAA,SAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAAA,CAAeN,EAAM,mBAAmB,CAExDO,EAAW,IAAIC,SADN,IAAIC,YAAY,I,OAE/BF,EAAS,QAAQ,CACf,EACA,6C,kwCCRW,OAAMG,EAQN,U,iBAAb,oBACE,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,IAAMC,EAAK,IAAIC,UAAU,EAAK,MAAM,CACpCD,CAAAA,EAAG,MAAM,CAAG,KACV,EAAK,EAAE,CAAGA,EACVF,EAAQE,EACV,EACAA,EAAG,OAAO,CAAGE,AAAAA,IACXH,EAAOG,GACP,EAAK,OAAO,CAACA,EACf,EACAF,EAAG,SAAS,CAAGE,AAAAA,GAAK,EAAK,SAAS,CAACA,EACrC,EACF,I,CAGO,YAAYC,CAAmB,CAAE,C,IACtCC,C,AAAO,QAAPA,CAAAA,EAAAA,IAAI,CAAC,EAAE,AAAD,GAANA,AAAAA,KAAAA,IAAAA,GAAAA,EAAS,IAAI,CAACC,ACTX,SAAcC,CAAe,EAClC,GAAIA,EAAI,OAAO,CAAE,CACf,IAAMC,EAASC,EAAiBtB,EAAM,mBAAmB,EACnDuB,EAAOC,KAAK,SAAS,CAACJ,EAAI,OAAO,EAEjCK,EAAaC,AADH,IAAIC,cAAc,MAAM,CAACJ,GACd,MAAM,CAEjC,OADAF,EAAO,SAAS,CAAC,EAAGI,EAAY,IACzB,IAAIpB,KAAK,CAACgB,EAAQE,EAAK,CAChC,CACA,IAAMK,EAASN,IACTO,EAAOT,EAAI,IAAI,EAAI,IAAIf,KAU7B,OAFAuB,EAAO,SAAS,CAAC,EAAGC,EAAK,IAAI,CAAE,IAExB,IAAIxB,KAAK,CAACuB,EAAQC,EAAK,CAChC,EDZuBZ,GACrB,CAGO,UAAUD,CAAoB,CAAE,CACrC,GAAI,CACFA,EAAE,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,AAACc,IACzB,IAAMC,EAAOC,EAAwBF,GACrCG,QAAQ,GAAG,CAAC,SAAUF,GAClBA,EAAK,WAAW,GAAK/B,EAAM,oBAAoB,EACjDkC,EAAkBH,EAAK,OAAO,EAE5BA,EAAK,WAAW,GAAK/B,EAAM,0BAA0B,EACvD,IAAI,CAAC,uBAAuB,CAAC+B,EAAK,OAAO,CAG7C,EACF,CAAE,MAAOf,EAAG,CACV,IAAI,CAAC,OAAO,CAACA,EACf,CACF,CACc,wBAAwBa,CAAiB,CAAE,C,iBAAzD,oBACE,IAAMM,EAAc,MAAM,EAAK,QAAQ,CAAC,eAAe,CACrD,IAAIC,WAAWP,GAAM,MAAM,EAEvBC,EAAS,EAAK,QAAQ,CAAC,kBAAkB,EAC/CA,CAAAA,EAAO,MAAM,CAAGK,EAChBL,EAAO,OAAO,CAAC,EAAK,QAAQ,CAAC,WAAW,EACxCA,EAAO,KAAK,CAAC,EACf,I,CACQ,QAAQd,CAAM,CAAE,CACtBiB,QAAQ,KAAK,CAACjB,GACd,IAAI,CAAC,OAAO,EACd,CACQ,SAAU,C,IAChBE,C,AAAO,QAAPA,CAAAA,EAAAA,IAAI,CAAC,EAAE,AAAD,GAANA,AAAAA,KAAAA,IAAAA,GAAAA,EAAS,KAAK,EAChB,CAzDA,YAAYmB,CAAuB,CAAE,CACnC,IAAI,CAAC,MAAM,CAAGA,EAAM,MAAM,CAC1B,IAAI,CAAC,QAAQ,CAAG,IAAIC,YACtB,CAuDF,CEsBA,MAhFc,KACZ,IAAMC,EAAcC,AAAAA,CAAAA,EAAAA,EAAAA,MAAAA,AAAAA,IACdC,EAAcD,AAAAA,CAAAA,EAAAA,EAAAA,MAAAA,AAAAA,EAA2B,MACzC,CAACE,EAAWC,EAAa,CAAGC,AAAAA,CAAAA,EAAAA,EAAAA,QAAAA,AAAAA,EAAiB,IAC7CC,EAAeL,AAAAA,CAAAA,EAAAA,EAAAA,MAAAA,AAAAA,IACfM,EAAkBN,AAAAA,CAAAA,EAAAA,EAAAA,MAAAA,AAAAA,IAClBO,EAAeC,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,EAAY,oBAC/B,OAAO,IAAIrC,QAAQ,CAACC,EAASC,KACvBoC,UAAU,YAAY,CAAC,YAAY,CACrCA,UAAU,YAAY,CAAC,YAAY,CAAC,CAAE,MAAO,EAAK,GAAG,IAAI,CAACC,AAAAA,IACxDT,EAAY,OAAO,CAAGS,EACtBtC,EAAQsC,EACV,GAEArC,EAAO,KAEX,EACF,GAAG,EAAE,EAECsC,EAAmBH,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,EAAY,KACnC,IAAMI,EAAa,IAAI1C,EAAgB,CAErC,OAAQ,wCACV,GAEA,OADAoC,EAAgB,OAAO,CAAGM,EACnBA,EAAW,OAAO,EAC3B,EAAG,EAAE,EAECC,EAAcL,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,EAAY,oBAC9B,GAAI,CACF,IAAMM,EAAS,MAAMH,IAGrB,GAFAN,EAAa,OAAO,CAAGS,EACvB,MAAMP,IACF,CAACN,EAAY,OAAO,CACtB,MAEFF,CAAAA,EAAY,OAAO,CAAG,GAAIgB,CAAAA,GAAAA,EAAUd,EAAY,OAAO,CAAE,CACvD,KAAM,QACN,aAAce,EAAAA,mBAAmBA,CACjC,SAAU,YACV,sBAAuB,EACvB,gBAAiB,KACjB,YAAa,GACb,UAAW,IACL,gBAAgBC,GAAc,oBAClC,IAAMH,EAAST,EAAa,OAAO,CAC7BO,EAAaN,EAAgB,OAAO,CAC1C,GAAI,EAACQ,IAAU,CAACF,GAGhB,IAAMM,EAAMD,EAAa,KAAK,CAAC,IACzB5B,EAAO5B,EAAuByD,EAChCJ,CAAAA,EAAO,UAAU,GAAKA,EAAO,IAAI,EACnCF,EAAW,WAAW,CAAC,CACrB,MAAO,YACPvB,KAAAA,CACF,GAEJ,IACF,GACAU,EAAY,OAAO,CAAC,cAAc,EACpC,CAAE,MAAOvB,EAAG,CACViB,QAAQ,KAAK,CAACjB,EAChB,CACF,GAAG,CAAC+B,EAAcI,EAAiB,EAEnC,MACE,WAAC,OAAI,UAAU,O,UACb,UAACQ,EAAAA,CAAMA,CAAAA,CACL,QAAS,KACPN,GACF,E,SACD,0B,GAGD,WAAC,K,UAAE,yCAASX,E,KAGlB,ECxFA,EAAgB,IAER,UAACkB,EAAAA,EAAaA,CAAAA,C,SACV,UAACC,EAAAA,EAAMA,CAAAA,C,SAEH,gB,8FCLhB,MAAeC,AAAAA,CAAAA,EAAAA,A,SAAAA,EAAAA,AAAAA,EAAoB,CAAC,E,2rFCFpCC,OAAO,eAAe,CAAG,E"}